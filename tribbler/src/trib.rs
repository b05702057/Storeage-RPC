#![allow(dead_code)]
//! Package trib defines basic interfaces and constants
//! for the Tribbler service implementation.
use std::sync::Arc;

use serde::{Deserialize, Serialize};

use crate::err::TribResult;

/// Maximum length of a username
#[allow(dead_code)]
pub const MAX_USERNAME_LEN: usize = 15;

/// Maximum length of a tribble
#[allow(dead_code)]
pub const MAX_TRIB_LEN: usize = 140;

/// Maximum count of tribbles for `Home()` and `Tribs()`
#[allow(dead_code)]
pub const MAX_TRIB_FETCH: usize = 100;

/// Minimum count of users required for `ListUsers()`
#[allow(dead_code)]
pub const MIN_LIST_USER: usize = 20;

/// Maximum count of users that one can follow
#[allow(dead_code)]
pub const MAX_FOLLOWING: usize = 2000;

/// A [Trib] is a post by a user to the tribbler service.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Trib {
    /// who posted this trib
    pub user: String,
    /// the content of the trib
    pub message: String,
    /// the physical timestamp when posted
    pub time: u64,
    /// the logical timestamp when posted
    pub clock: u64,
}

/// A tribbler server object represents the front-end interface
/// that serves tribbler-related data.
pub trait Server {
    /// Creates a user.
    /// Returns error when the username is invalid;
    /// returns error when the user already exists.
    /// Concurrent sign ups on the same user might both succeed with no error.
    fn sign_up(&self, user: &str) -> TribResult<()>;

    /// List 20 registered users.  When there are less than 20 users that
    /// signed up the service, all of them needs to be listed.  When there
    /// are more than 20 users that signed up the service, an arbitrary set
    /// of at lest 20 of them needs to be listed.
    /// The result should be sorted in alphabetical order.
    fn list_users(&self) -> TribResult<Vec<String>>;

    /// Post a tribble.  The clock is the maximum clock value this user has
    /// seen so far by reading tribbles or clock sync.
    /// Returns error when who does not exist;
    /// returns error when post is too long.
    fn post(&self, who: &str, post: &str, clock: u64) -> TribResult<()>;

    /// List the tribs that a particular user posted.
    /// Returns error when user has not signed up.
    fn tribs(&self, user: &str) -> TribResult<Vec<Arc<Trib>>>;

    /// Follow someone's timeline.
    /// Returns error when who == whom;
    /// returns error when who is already following whom;
    /// returns error when who is tryting to following
    /// more than trib.MaxFollowing users.
    /// returns error when who or whom has not signed up.
    /// Concurrent follows might both succeed without error.
    /// The count of following users might exceed trib.MaxFollowing=2000,
    /// if and only if the 2000'th user is generated by concurrent Follow()
    /// calls.
    fn follow(&self, who: &str, whom: &str) -> TribResult<()>;

    /// Unfollow someone's timeline.
    /// Returns error when who == whom.
    /// returns error when who is not following whom;
    /// returns error when who or whom has not signed up.
    fn unfollow(&self, who: &str, whom: &str) -> TribResult<()>;

    /// Returns true when who following whom.
    /// Returns error when who == whom.
    /// Returns error when who or whom has not signed up.
    fn is_following(&self, who: &str, whom: &str) -> TribResult<bool>;

    /// Returns the list of following users.
    /// Returns error when who has not signed up.
    /// The list have users more than trib.MaxFollowing=2000,
    /// if and only if the 2000'th user is generate d by concurrent Follow()
    /// calls.
    fn following(&self, who: &str) -> TribResult<Vec<String>>;

    /// List the tribs of someone's following users (including himself).
    /// Returns error when user has not signed up.
    fn home(&self, user: &str) -> TribResult<Vec<Arc<Trib>>>;
}

/// Checks if a username is a valid one. Returns true if it is.
pub fn is_valid_username(s: &str) -> bool {
    if s.is_empty() {
        return false;
    }

    if s.len() > MAX_USERNAME_LEN {
        return false;
    }

    for r in s.chars() {
        if !('a'..='z').contains(&r) && !('0'..='9').contains(&r) {
            return false;
        }
    }
    true
}

#[cfg(test)]
mod test {
    use crate::trib::is_valid_username;

    #[test]
    fn valid_usernames() {
        assert_eq!(true, is_valid_username("h8liu"));
        assert_eq!(true, is_valid_username("rkapoor"));
        assert_eq!(true, is_valid_username("fenglu"));
    }
}
